// Simple feed forward neural network that uses backpropagation algorithm.

function createLayer(layersize,bias,output) {
    var layer = Object.create(nil)
    layer.layersize =layersize
    layer.weights = []
    layer.output = []
    layer.bias = bias

    layer
}

function sigmoid(x) {
    return 1.0 / (1.0 + Math.exp(-x))
}

function shuffle(x) {
    for i in range(x.length,1) {
        var tmp = x[i]
        var idx = Math.randomInt(0,i+1)
        x[i] = x[idx]
        x[idx] = tmp
    }
}

function NeuralNet(input_size,output_size,hidden) {
    this = Object.create(nil)
    this.input_layer = createLayer(input_size,0,false)
    this.output_layer = createLayer(output_size,0,true)
    this.hidden_layers = []
    this.learning_rate = 0.5
    this.weights = []
    for i in hidden {
        this.hidden_layers.push(createLayer(hidden.length,0,false))
    }

    this.create_random_weights = function(layer,next_layer) {
        for i in range(0,layer.layersize) {
            layer.weights.push([])
            for j in range(0,next_layer) {
                layer.weights[i].push(0)
                layer.weights[i][j] = Math.random() * 2 - 1
            }
        }
    }
    this.create_random_weights(this.input_layer,this.hidden_layers[0].layersize)
    var i = 0
    while i < this.hidden_layers.length {
        var next_layer_num = 0
        if i!=this.hidden_layers.length - 1 {
            next_layer_num = this.hidden_layers[i+1].layersize
        } else {
            next_layer_num = this.output_layer.layersize
        }
        this.create_random_weights(this.hidden_layers[i],next_layer_num)
        i = i + 1
    }

    this.total_error = function(prediction,actual) {
        var error = 0
        for i in range(0,prediction.length) {
            error = error + Math.pow((actual[i] - prediction[i]),2)
        }
        return 0.5 * error
    }

    this.run_input = function(layer,prevlayer) {
        for i in range(0,layer.layersize) {
            var input = 0
            for j in range(0,prevlayer.output.length) {
                if prevlayer.weights[j][i] == 0 {
                    print("zero shit")
                }
                if prevlayer.output[j] == 0 {
                    
                } else {
                    var w = prevlayer.weights[j][i]
                    var p = prevlayer.output[j]
                    if (w == 0 || p == 0) || (w == undefined || p == undefined)  {
                        
                    } else {
                        input = input + 
                                prevlayer.output[j] * prevlayer.weights[j][i]
                    }
                }
            }
            
            layer.output[i] = sigmoid(input + prevlayer.bias)
        }
        
    }

    this.forward = function(input) {
        this.input_layer.output = input
        
        this.run_input(this.hidden_layers[0],this.input_layer)
        var i = 1
        while i <= this.hidden_layers.length - 1 {
            this.run_input(this.hidden_layers[i],this.hidden_layers[i-1])
            i = i + 1
        }
        
       
        this.run_input(this.output_layer,this.hidden_layers[this.hidden_layers.length-1])
        
        return nil
    }

    this.predict = function(input) {
        if input.length != this.input_layer.layersize {
            print("ERROORRR")
            throw "length of inputs array does not match"
        }
        var result = []
        this.forward(input)
        var output = this.output_layer.output
        for i in range(0,output.length) {
            result[i] = output[i]
        }
        return result
    }

    this.backward = function(target) {
        var output = this.output_layer.output
        this.output_layer.deltas = []
        for i in range(0,output.length) {
            var error = output[i] - target[i]
            this.output_layer.deltas[i] = error * output[i] * (1 - output[i])
        }

        var last_index = this.hidden_layers.length - 1
        var weights = this.hidden_layers[last_index].weights
        output = this.hidden_layers[last_index].output
        var deltas = this.output_layer.deltas
        this.hidden_layers[last_index].deltas = []
        for i in range(0,output.length) {
            var error = 0
            for j in range(0,deltas.length) {
                error = error + deltas[j] * weights[i][j]  
                weights[i][j] = weights[i][j] - this.learning_rate * deltas[j] * output[i]   
            }
            this.hidden_layers[last_index].deltas[i] = error * output[i] * (1-output[i])
        }

        var i = this.hidden_layers.length - 2
        while i >= 0 {
            var output = this.hidden_layers[i].output
            var weights = this.hidden_layers[i].weights
            this.hidden_layers[i].deltas = []
            var deltas = this.hidden_layers[i+1].deltas
            for j in range(0,output.length) {
                var error = 0
                for k in range(0,deltas.length) {
                    error = error + deltas[k] * weights[j][k]
                    weights[j][k] = weights[j][k] - this.learning_rate * deltas[k] * output[j]
                }
                this.hidden_layers[i].deltas[j] = error * output[j] * (1-output[j])
            }
            i = i - 1
        }

        var weights = this.input_layer.weights
        var output =  this.input_layer.output
        this.input_layer.deltas = []
        deltas = this.hidden_layers[0].deltas
        for i in range(0,output.length) {
            var error = 0
            for j in range(0,deltas.length) {
                error = error + deltas[j] * weights[i][j]
                weights[i][j] = weights[i][j] - this.learning_rate * deltas[j] * output[i]
            }
            this.input_layer.deltas[i] = error * output[i] * (1-output[i])
        }
    }

    this.learnSingle = function(input,output) {
        this.total_err = this.total_error(this.predict(input),output)
        this.backward(output)
    }
    this.learn = function(data,iterations) {
        for i in range(0,iterations) {
            for example in data {
                //shuffle(data)
                this.learnSingle(example.input,example.output)
                
            }
        }
    }

    this
}

var nn = NeuralNet(2,1,[2])

var x1 = Object.create(nil)
x1.input = [0,0] x1.output = [0]
var x2 = Object.create(nil)
x2.input = [0,1] x2.output = [1]
var x3 = Object.create(nil)
x3.input = [1,0] x3.output = [1]
var x4 = Object.create(nil)
x4.input = [1,1] x4.output = [0]

var data = [x1,x2,x3,x4]

nn.learn(data,1000)

print("0^1 = " + nn.predict([0,1]))
